local log = require("log.log")
local saver = require("saver.saver")
local schedule = require("schedule.schedule")
local druid = require("druid.druid")
local debug_page_schedule = require("widget.debug_page_schedule.debug_page_schedule")
local properties_panel = require("widget.properties_panel.properties_panel")
local fps_panel = require("widget.fps_panel.fps_panel")
local memory_panel = require("widget.memory_panel.memory_panel")

function init(self)
	self.druid = druid.new(self)
	schedule.set_logger(log.get_logger("schedule"))

	saver.init()
	saver.bind_save_state("schedule", schedule.get_state())

	self.druid:new_widget(fps_panel, "fps_panel")
	self.druid:new_widget(memory_panel, "memory_panel")

	if false then
		-- Create various events for testing the debug panel
		-- 1. Simple pending event with duration
		schedule.event("craft_sword")
			:category("craft")
			:after(30)
			:duration(60)
			:payload({ item = "sword", quality = "rare" })
			:save()

		-- 2. Active event (starts immediately)
		local active_event = schedule.event("daily_quest")
			:category("quest")
			:duration(300)
			:payload({ quest_id = "daily_001", reward = "gold" })
			:save()
		active_event:start()

		-- 3. Event with cycle (every N seconds)
		schedule.event("energy_regen")
			:category("resource")
			:after(10)
			:duration(5)
			:cycle("every", { seconds = 60, anchor = "start" })
			:payload({ resource = "energy", amount = 10 })
			:save()

		-- 4. Event with weekly cycle
		schedule.event("weekly_boss")
			:category("boss")
			:start_at("2026-01-05T14:00:00")
			:duration(3600)
			:cycle("weekly", { weekdays = {"mon", "wed", "fri"}, time = "14:00" })
			:payload({ boss_name = "Dragon", difficulty = "hard" })
			:save()

		-- 5. Event with monthly cycle
		schedule.event("monthly_reward")
			:category("reward")
			:start_at("2026-01-15T00:00:00")
			:duration(86400)
			:cycle("monthly", { day = 15, time = "00:00" })
			:payload({ reward_type = "premium", amount = 1000 })
			:save()

		-- 6. Infinity event (never ends)
		schedule.event("premium_boost")
			:category("boost")
			:after(5)
			:infinity()
			:payload({ boost_type = "xp", multiplier = 2.0 })
			:save()

		-- 7. Event with catch_up enabled
		schedule.event("offline_progress")
			:category("craft")
			:after(20)
			:duration(120)
			:catch_up(true)
			:payload({ craft_type = "potions", count = 5 })
			:save()

		-- 8. Event chained after another event
		schedule.event("chain_event")
			:category("quest")
			:after("craft_sword")
			:duration(30)
			:payload({ step = 2, quest_chain = "main_story" })
			:save()

		-- 9. Event with conditions (requires registration)
		schedule.register_condition("has_item", function(data)
			-- Mock condition - always returns true for demo
			return true
		end)
		schedule.event("conditional_event")
			:category("quest")
			:after(15)
			:duration(45)
			:condition("has_item", { item_id = "key", quantity = 1 })
			:payload({ quest_id = "conditional_001" })
			:save()

		-- 10. Completed event (for testing different statuses)
		local completed_event = schedule.event("completed_task")
			:category("task")
			:duration(10)
			:payload({ task_name = "tutorial_complete" })
			:save()
		completed_event:start()
		completed_event:finish()

		-- 11. Paused event
		local paused_event = schedule.event("paused_activity")
			:category("activity")
			:duration(180)
			:payload({ activity_type = "mining" })
			:save()
		paused_event:start()
		paused_event:pause()

		-- 12. Cancelled event
		local cancelled_event = schedule.event("cancelled_mission")
			:category("mission")
			:after(25)
			:duration(90)
			:payload({ mission_id = "rescue_001" })
			:save()
		cancelled_event:cancel()
	end

	schedule.event():duration(60):save()
	schedule.event():duration(60):save()
	schedule.event():duration(60):save()

	schedule.on_event:subscribe(function(event)
		print("Event: " .. event.id, event.category, event.payload)
		pprint(event)
	end)

	pprint("Active", schedule.filter(nil, "active"))

	self.properties_panel = self.druid:new_widget(properties_panel, "properties_panel")
	self.properties_panel:add_button(function(button)
		button:set_text_property("Schedule Panel")
		button:set_text_button("Open")
		button.button.on_click:subscribe(function()
			debug_page_schedule.render_properties_panel(self.druid, self.properties_panel)
		end)
	end)
end


function final(self)
	self.druid:final()
end


function update(self, dt)
	self.druid:update(dt)
	schedule.update()
end

function on_message(self, message_id, message, sender)
	self.druid:on_message(message_id, message, sender)
end


function on_input(self, action_id, action)
	self.druid:on_input(action_id, action)
end

